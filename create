#!/usr/bin/env ruby
require "English"
require_relative "ytrello"

if ARGV.empty? || ARGV[0].include?("-h")
  puts "Usage: #{$PROGRAM_NAME} bug_number"
  puts "  Creates a trello card for a bug, links the bug to the card"
  exit 0
end

setup_trello
setup_bicho

# abbreviate a SUSE product name
def abbrev(s)
  s
    .sub("openSUSE", "oS")
    .sub("SUSE Linux Enterprise Desktop", "SLED")
    .sub("SUSE Linux Enterprise Server",  "SLES")
    .sub(/\(.*\)/, "")          # remove superfluous abbreviation
    .sub(" SP", "-SP")
    .sub(" Factory", "-TW")     # Tumbleweed
    .tr(" ", "")
end

# in that board:
PRODUCT_LISTS = {
  /SLE[SD]12-SP1/ => "5502d6719b0d5db70bcf6655", # SLE12-SP1 development
  /SLE[SD]12/     => "5507f04f2c885ffbdd53208a", # SLE12-maintenance
  # not yet:
  # /SLE[SD]12-SP2/ => "5538994821027776154180eb",      # SLE12-SP2 development
  # /SLE[SD]12-SP1/ => "5507f04ba946797c971ecde3",      # SLE12-SP1 maintenance
  /SLE[SD]11-SP4/ => "5507f0549c920252e89da5ad", # SLE11-SP4 development
  /SLE[SD]11/     => "5507f140ab44b6bcfcc6c561", # SLE11-maintenance
  /^oS/           => "550800984de3079fa9ded12a", # openSUSE
  # fallback
  /./             => "5507f28d31c1cfac7a83eb72"  # Generic Ideas
}

def product_to_list(product)
  PRODUCT_LISTS.to_a.each do |pattern, list_id|
    return list_id if product =~ pattern
  end
  raise "Internal error, PRODUCT_LISTS did not match"
end

def markdown_link(text, url)
  "[#{text}](#{url})"
end

def bz_markdown_link(id)
  markdown_link("bsc##{id}", "#{BUGZILLA_URL}/show_bug.cgi?id=#{id}")
end

def bicho_details(bug_id)
  bug = Bicho.client.get_bugs(bug_id).first
  raise "Bug ##{bug_id} not found" unless bug
  bug.priority.match(/^(\S+)\s/)
  { summary: bug.summary, product: bug.product, priority: Regexp.last_match(1) }
end

# create a card description text
# @param bug_id bug number
# @return [String] description text in the Markdown format
def card_description(bug_id)
  descr = <<EOT
Bugzilla: #{bz_markdown_link(bug_id)}

---
## Review
- Pull Request: *URL here*
EOT

  # just to avoid the trailing blank errors in the heredoc
  descr + "- "
end

bug_id      = ARGV[0]
details     = bicho_details(bug_id)
product     = abbrev(details[:product])
card_name   = "#{product} (#{details[:priority]}) ##{bug_id} #{details[:summary]}"
description = card_description(bug_id)
list_id     = product_to_list(product)
# list_id     = "546336636415e12617f88e47" # My work / Done

debug "Trello query"
inc_board  = Trello::Board.find(INC_BOARD_ID)  || raise
t1_board = Trello::Board.find(TEAM_1_BOARD_ID) || raise
ta_board = Trello::Board.find(TEAM_A_BOARD_ID) || raise

labels = inc_board.labels(false) # false: objects; true: names
new_item_label = labels.find { |i| i.name =~ /new.item/i } || raise

Trello::List.find(list_id) ||
  raise("Cannot find list #{list_id} to represent #{details[:product]}")

inc_cards  = to_array inc_board.cards
t1_cards   = to_array t1_board.cards
ta_cards   = to_array ta_board.cards

existing = (inc_cards + t1_cards + ta_cards).find_all do |c|
  c.name =~ /\D#{bug_id}\D/
end

card = nil
if existing.empty?
  debug "Creating"
  card = Trello::Card.create(list_id: list_id,
                             name:    card_name,
                             desc:    description,
                             pos:     "top")
  card.add_label(new_item_label)
  puts "Created #{bug_id} => #{card.short_url}"
else
  puts "Card for bug already exists:"
  existing.each { |c| puts c.url }
  card = existing.first if existing.size == 1
end

if card
  debug "Assigning card URL in Bugzilla"
  system "./addurl", bug_id.to_s, card.short_url.to_s
end
